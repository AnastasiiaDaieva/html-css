/* Задание
Для селектора p задайте свойство color и значение red, свойство font-size и значение 20px; */
p { color: red; font-size: 20px; }

/* Задание
Для селектора * (любой элемент) задай свойство margin и значение 0, свойство padding и значение 0; */
* { margin: 0; padding: 0; }

/* Задание
Для тега li отмени свойство  list-style с помощью значения none. Задай свойству color значение green; Убедись на примере изменения цвета текста, что у тега более высокий приоритет, чем у *. */

* { color: red; } li { list-style: none; color: green; }

/* Задание
Для класса rule задай свойство  list-style и значение upper-roman, свойство color и значение navy;
Убедись на примере появления римской нумерации и изменения цвета текста, что у класса более высокий приоритет, чем у тега. */

li { list-style: none; color: green; } .rule { list-style: upper-roman; color:
navy; }

/* Задание
Двум элементам с классом common-rule добавлены классы first-rule и last-rule, т.е. создана композиция с классом common-rule.
Добавьте CSS правила для класса first-rule и last-rule под текстом с правилом для класса common-rule (почему именно такое расположение будет рассмотрено позже).
Для класса first-rule добавьте свойство color и значение red.
Для класса last-rule добавьте свойство color и значение green. */

.common-rule { list-style: upper-roman; font-size: 20px; } .first-rule { color:
red; } .last-rule { color: green; }

/* Задание
В CSS добавь класс active к селекторам button и link так, чтобы

правило color: red применилось только к элементу button, содержащему одновременно класс btn и active;
правило font-weight: 700 применилось только к элементу a, содержащему одновременно класс link и active. */

.btn { border: none; padding: .25rem 1.25rem; } .link { text-decoration: none;
color: navy; } /* Напиши свой код под этой строкой */ .btn.active { color: red;
} .link.active { font-weight: 700; }

/* Задание
Добавь псевдокласс :hover и :focus так, чтобы для класса link применялось свойство opacity: 1 при наведении курсора или получения фокуса с помощью клавиши tab */
.link { text-decoration: none; color: navy; opacity: 0.5; } /* Напиши свой код
под этой строкой */ .link:hover, .link:focus { opacity: 1; }

/* Задание
Для селектора в виде атрибута [type] задай свойство color со значением white.
Повышаем специфичность. Для селектора в виде тега button и атрибута [type="reset"] задай свойство color со значением green */
[type] { color: white; } button[type="reset"] { color: green; }

/* Задание
Для ссылок с атрибутом href, значение которых начинается с ./ задай цвет текста red.
Для ссылок с атрибутом href, значение которых начинается с https задай цвет текста navy.
Специфичность селекторов должна быть минимальной. */

.link { text-decoration: none; } [href^="./"] { color: red; } [href^="https"] {
color: navy; }

/* Задание
Для атрибутов, заканчивающихся на html задай цвет текста green.
Для атрибутов, заканчивающихся на css задай цвет текста orangered.
Специфичность селекторов должна быть минимальной. */

.link { text-decoration: none; } [href$="html"] { color: green; } [href$="css"]
{ color: orangered; }

/* Задание
Для атрибутов, содержащих about задай цвет текста green.
Для атрибутов, содержащих com задай цвет текста orangered.
Специфичность селекторов должна быть минимальной. */

.link { text-decoration: none; } [href*="about"] { color: green; } [href*="com"]
{ color: orangered; }

/* Задание
Добавь CSS правило с id селектором sending со свойством background-color и значением teal, со свойством color и значением white.

Обрати внимание на то что у id более высокий приоритет, чем у класса. */
.warning { background-color: white; color: red; } #sending { background-color:
teal; color: white; }

/* Задание
Задайте элементу div инлайн стили CSS со свойством background-color и значением orange, со свойством color и значением navy.

Обратите внимание на более высокий приоритет у инлайн-стилей по сравнению с классом и id. */

<div class="warning" id="inline" style="background-color: orange; color: navy">
  Инлайн стили нежелательно использовать из-за более высокого приоритета чем у
  id, а также из-за сложности c поддержкой и переиспользованем кода.
</div>

/* Задание
Добавь !important обеим значениям свойств селектора div.

Обрати внимание на то что у div приоритет изменился и стал более высоким чем у инлайн. */

div { 
  background-color: navy!important; 
  color: white !important; 
} 

.warning {
background-color: white; color: red; } #inline { background-color: red; color:
white; }

/* Задание
Добавь к селектору menu-item еще один класс menu так, чтобы оба свойства display и vertical-align применились только к прямым потомкам класса menu, но не к потомкам sub-menu. */

ul { padding: 0; list-style: none; } .menu>.menu-item { display: inline-block;
vertical-align: top; }

/* Задание
В html коде дано меню, которое содержит два подменю, вложенных одно в другое. В css кода все подменю с классом sub-menu скрыты с помощью свойства opacity. Необходимо разместить элементы li списка с классом menu по горизонтали, а li списков с классом sub-menu должны остаться в вертикальном положении. Также при наведении курсором на элемент li должно показываться скрытое меню.

Для этого

Добавь к селектору menu все элементы с селектором класса menu-item, которые являются первыми потомками списка с классом menu.
Добавь к селектору sub-menu все элементы с селектором класса menu-item, которые являются потомками списка с классом sub-menu на любом уровне вложенности.
Добавь к селектору menu-item:hover все элементы, которые являются потомками элемента с классом menu-item на любом уровне вложенности.
Обрати внимание на поведение элементов меню при hover до и после успешного выполнения задания. */

ul { padding: 0; list-style: none; } .menu>.menu-item { display: inline-block;
vertical-align: top; opacity: 1; } .sub-menu .menu-item { opacity: 0;
margin-left: 100px; } .menu-item:hover .menu-item { opacity: 1; }

/* Задание
Добавь к селектору item-1 еще один класс item так, чтобы свойство color: red применилось только к первому соседу - элементу с классом item-2 */
.item-1+.item { color: red; }

/* Задание
Добавь к селектору item-2 еще один класс item так, чтобы свойство color со значением red применилось ко всем нижним соседям этого элемента.

Т.е. правило должно примениться к элементам с классом item-3 и item-4.

Ни к каким другим элементам color: red больше применяться не должно. */
.item-2~.item { color: red; }

/* Задание
Не меняя селекторы и правила CSS сделай так, чтобы цвет текста всех элементов стал maroon (перемести CSS правила). */
.headline.title{ color: navy; } .title[title] { color: maroon; }

/* Задание
В коде html есть элемент ul с классом cards и есть последний элемент li с классом last-of-type. С помощью наследования нужно изменить цвет текста для элементов-потомков этих двух элементов. Для этого необходимо:

селектору класса cards задать цвет текста navy;
селектору класса last-of-type задать цвет текста firebrick. */
.cards { color: navy; } .last-of-type { color: firebrick; }

/* Задание
Т.к. цвет текста для ссылок не наследуется, то задай ссылке цвет green, используя класс в качестве селектора

.list { padding-left: 0; list-style: none; color: green; } .list-link { color:
green; }

Задание
Подключите в правильном порядке файлы стилей, расположенных в папке css:

css/modern-normalize.css
css/style.css

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link href="css/modern-normalize.css" rel="stylesheet" />
    <link href="css/style.css" rel="stylesheet" />
  </head>
  <body></body>
</html>

Задание
В формате rgb, используя только значения от 0 до 255:

задай классу box белый цвет текста и черный фон
задай классу red максимально красный фон
задай классу green максимально зеленый фон
задай классу blue максимально синий фон */

.box { background-color: rgb(0, 0, 0); color: rgb(255, 255, 255); } .red {
background-color: rgb(255, 0, 0); } .green { background-color: rgb(0, 255, 0); }
.blue { background-color: rgb(0, 0, 255); }

/* Задание
В сокращенном hex формате

задай классу box белый цвет текста и черный фон;
задай классу red максимально красный фон;
задай классу green максимально зеленый фон;
задай классу blue максимально синий фон. */

.box { background-color: #000; color: #fff; } .red { background-color: #f00 }
.green { background-color: #0f0 } .blue { background-color: #00f }

/* Задание
Сделай цвет текста контрастным - добавь белый цвет в формате hsl для классов lightness-25 и lightness-0 */

.lightness { width: 50px; height: 50px; line-height: 50px; margin: 0.5rem;
text-align: center; border: 1px solid gold; } .lightness-100 { background-color:
hsl(0, 100%, 100%); } .lightness-75 { background-color: hsl(0, 100%, 75%); }
.lightness-50 { background-color: hsl(0, 100%, 50%); } .lightness-25 {
background-color: hsl(0, 100%, 25%); color: hsl(100, 100%, 100%); } .lightness-0
{ background-color: hsl(0, 100%, 0%); color: hsl(100, 100%, 100%); }

/* Задание
Задай свойство opacity селекторам .opacity:hover и .opacity:focus так, чтобы прозрачность отсутствовала.
Задай свойству background-color селекторам .transparent:hover и .transparent:focus значение - именованный цвет прозрачности. */

.container { padding: 1rem; background-color: navy; } .box { width: 200px;
height: 50px; margin: 1rem auto; color: #fff; font-size: 24px; line-height:
50px; text-align: center; cursor: pointer; background-color: orchid; border: 4px
solid gold; } .opacity { opacity: .5; } /* Напиши код под этой строкой */
.opacity:hover, .opacity:focus { opacity: 1; } .transparent:hover,
.transparent:focus { background-color: transparent; }

/* Задание
Задай свойству background-color селектору [data-color="rgba"]:hover значение - полупрозрачный цвет в формате rgba вместо заданного в формате rgb.
Задай свойству background-color селектору [data-color="hsla"]:hover значение - полупрозрачный цвет в формате hsla вместо заданного в формате hsl.
Задай свойству background-color селектору [data-color="hexa"]:hover значение - полупрозрачный цвет в формате hexa вместо заданного в формате hex. */
[data-color] { padding: 0.5rem 1.5rem; border: none; background-color: #008;
color: #fff; font-size: 1.5rem; } [data-color="rgba"]:hover { background-color:
rgba(0, 0, 136, .5); } [data-color="hsla"]:hover { background-color: hsla(240,
100%, 27%, .5); } [data-color="hexa"]:hover { background-color: #00008a80; }

/* BLOCK 4
Задание
Для текста абзаца (параграфа)

задай селектор в виде имени тега ;
сделай отступ первой строки на 40px. */
p { text-indent: 40px; }

/* Задание
Используй название класса columns в качестве селектора.
Добавь css свойство text-indent с отступом первой строки абзаца в 40px.
Добавь css свойство column-count значение для создания 2-х колонок. */
.columns { text-indent: 40px; column-count: 2; }

/* Задание
Размести текст и элементы button внутри элементов div с помощью свойства text-align в определенном горизонтальном порядке:

для элемента с классом left строчные элементы или текст должны быть прижаты влево;
для элемента с классом right строчные элементы или текст должны быть прижаты вправо;
для элемента с классом center строчные элементы или текст должны находиться по центру элемента div;
для элемента с классом justify строчные элементы или текст должны быть растянуты на всю ширину элемента div, если строка заполнена. */
.left { text-align: left; } .right { text-align: right; } .center { text-align:
center; } .justify { text-align: justify; }

/* Задание
Для font-size со значением 18px требуется отступ под строкой и над строкой по 9px. Задай элементу p свойство line-height в безразмерном виде. */
p { line-height: 2; }

/* Задание
Измени вертикальное расположение текста и блоков со свойством display: inline-block согласно расположению на рисунке. */
.boxes, .cards, .letter { font-size: 36px; height: 100px; padding: 1rem;
background-color: goldenrod; margin-bottom: 1rem; } .box-48 { font-size: 48px; }
.box-72 { font-size: 72px; } .card { height: 36px; width: 18px; } .card-48 {
height: 48px; width: 36px; } .card-72 { height: 72px; width: 48px; } /* Напиши
код под этой строкой */ .box, .card { display: inline-block; vertical-align:
top; background-color: blueviolet; } .letter::first-letter { font-size: 72px;
vertical-align: top; }

/* Задание
Измени вертикальное расположение текста и блоков со свойством display: inline-block согласно расположению на рисунке. */
.boxes, .cards, .letter { font-size: 36px; height: 100px; padding: 1rem;
background-color: goldenrod; margin-bottom: 1rem; } .box-48 { font-size: 48px; }
.box-72 { font-size: 72px; } .card { height: 36px; width: 18px; } .card-48 {
height: 48px; width: 36px; } .card-72 { height: 72px; width: 48px; } /* Напиши
код под этой строкой */ .box, .card { display: inline-block; vertical-align:
middle; background-color: blueviolet; } .letter::first-letter { font-size: 72px;
vertical-align: middle; }

/* Задание
Измени вертикальное расположение текста и блоков со свойством display: inline-block согласно расположению на рисунке. */
.boxes, .cards, .letter { font-size: 36px; height: 100px; padding: 1rem;
background-color: goldenrod; margin-bottom: 1rem; } .box-48 { font-size: 48px; }
.box-72 { font-size: 72px; } .card { height: 36px; width: 18px; } .card-48 {
height: 48px; width: 36px; } .card-72 { height: 72px; width: 48px; } /* Напиши
код под этой строкой */ .box, .card { display: inline-block; vertical-align:
bottom; background-color: blueviolet; } .letter::first-letter { font-size: 72px;
vertical-align: bottom; }

/* Задание
Задай или измени свойство text-transform. Значение возьмите из значения аргумента data-transform в коде html.

Обратите внимание на то, что значение применится к тексту из элемента span. */

[data-transform="none"] { text-transform: none; } [data-transform="uppercase"] {
text-transform: uppercase; } [data-transform="lowercase"] { text-transform:
lowercase; } [data-transform="capitalize"] { text-transform: capitalize; }

/* Задание
Найдите элементы с классом в html коде и селектор с тем же классом в css коде.
Для каждого такого элемента html перенесите значения из аргументов data-line, data-style и data-color в качестве значений для свойства text-decoration.
Для селектора с классом no перезапишите значение text-decoration с помощью значения из data-line. */

body { font-size: 36px; padding: 1rem; } /* Напиши код под этой строкой */ .up {
text-decoration: overline wavy red; } .through { text-decoration: line-through
dashed green; } .down { text-decoration: underline solid blue; } .no {
text-decoration: none; } .combi { text-decoration: underline overline double
grey; }

/* Задание
Для элемента li с классом one задай тень для текста. Для этого в коде html у элемента li с классом one найди атрибуты data. И задай в css коде селектору класса one свойство text-shadow со значениями:
смещение X (по горизонтали) взятое из значения атрибута data-x
смещение Y (по вертикали) взятое из значения атрибута data-y
blur (размытие) взятое из значения атрибута data-blur
color (цвет) взятое из значения атрибута data-color
Для элемента li с классом rings задай 4 тени разного цвета для буквы O. Селектору rings уже задано свойство text-shadow состоящее из 4 теней на разном расстоянии. Для того, чтобы задать цвет, в коде html у элемента li с классом one найди атрибут data-colors. Добавь эти цвета к значениям свойства text-shadow селектора rings согласно синтаксису для этого свойства (т.е. цвет должен быть в конце перчисления - перед запятой или точкой с запятой). Порядок цветов показан на рисунке: */
body { font-family: sans-serif; font-size: 36px; padding: 1rem; } /* offset-x |
offset-y | blur-radius | color */ .one { color: blue; text-decoration: underline
wavy; margin-bottom: 1rem; text-shadow: 3px 3px 2px hsla(0, 0%, 0%, .5) } .rings
{ color: orange; text-shadow: -15px -8px 0 blue, 14px -8px 0 black, 29px 0 0
green, 44px -8px 0 red; }

/* Задание
В коде html элемент ol с классом items содержит несколько потомков - элементы li c разными атрибутами. В коде css всем элементам, потомкам элемента с классом items задано расстояние между словами в 1rem.

Для двух элементов li с классом item-less и item-normal необходимо переопределить это расстояние c новыми значениями, взятыми из атрибутов data-wordspacing. Для этого:

создай два css правила с селекторами класса item-less и item-normal
задай свойству word-spacing значения, взятые из значений data-wordspacing элемента, имеющего в html тот же класс, что и селектор.
Обрати внимание на наследование свойства word-spacing */

.items { word-spacing: 1rem; } /* Напиши код под этой строкой */ .item-less {
word-spacing: -.25rem; } .item-normal { word-spacing: normal; }

/* Задание
В коде html элемент ol с классом items содержит несколько потомков - элементы li c разными атрибутами. В коде css всем элементам, потомкам элемента с классом items задано расстояние между буквами в .25rem.

Задай классам item-less и item-normal свойство letter-spacing.
Значения для свойства letter-spacing возьми из значения атрибута data-letterspacing
Обрати внимание на наследование этого свойства. */
.items { letter-spacing: .25rem; } /* Напиши код под этой строкой */ .item-less
{ letter-spacing: -.1rem; } .item-normal { letter-spacing: normal; }


/* BLOCK 5

Задание
Задай элементу с классом child ширину, равную половине ширины родительского элемента.

Обрати внимание на разное поведение блочных и строчных элементов при изменении значения ширины в css правиле.
Следует запомнить три правила, которые необходимо вспоминать при изменении размещения элемента на странице с помощью css:

Значение высоты (height) для любых элементов браузер вычисляет на основе высоты контента.
Значение ширины (width) для элементов со значениями display равными inline или inline-block вычисляет на основе ширины контента.
Значение ширины (width) для элементов со значением display равным block равно 100% ширины (width) родительского элемента.
При размещении блоков content box действует особая "гравитация" - все элементы стремятся "упасть" вверх в левый угол.

Точкой отсчета для построения прямоугольника content box является верхний левый угол.

Внимание
Размещать блочные элементы внутри строчных запрещено. */

.parent {
  background: teal;
  margin-bottom: 1rem;
}

.child {
  background: salmon;
  width: 50%;
}

/* Задание
Задай элементу с классом child минимальную ширину, равную 200px.

Обрати внимание на разное поведение блочных и строчных элементов при изменении значения ширины в css правиле. */

.parent {
  background: teal;
  margin-bottom: 1rem;
}

.child {
  width: 2%;
  min-width: 200px;
  background: salmon;
}

/* Задание
Задай элементу с классом child максимальную ширину, равную 200px.

Обрати внимание на разное поведение блочных и строчных элементов при изменении значения ширины в css правиле. */

.parent {
  background: teal;
  margin-bottom: 1rem;
}

.child {
  width: 90%;
  max-width: 200px;
  background: salmon;
}

/* Задание
Задай элементу с классом parent

минимальную высоту, равную 30px;
отступ на нижней стороне элемента в 1rem (отступ от соседнего элемента).
Обрати внимание на отсутствие на веб-странице элемента с высотой 0 и его появление при задании значения свойству min-height. */

.parent {
  background: teal;
  min-height: 30px;
  margin-bottom: 1rem;
}

.child {
  background: salmon;
}

/* Задание
Замени значение height на min-height у элемента с классом card.

Обрати внимание на то как min-height исправил ситуацию с переполнением контента. */

.card {
  background: teal;
  width: 200px;
  min-height: 300px;
}

/* Задание
Измени css свойства родительского элемента (элемента с классом parent) так, чтобы появились отступы от края до элемента-потомка, но ширина родительского элемента при этом осталась прежней. Для этого:

С помощью padding задай отступы в 1rem. Для описания значения padding используй самую короткую запись из одного значения.

Убедись, что геометрия (ширина) элемента с классом parent увеличилась на 2rem (за счет добавления ширины padding). Верни общую ширину блока к начальному значению, уменьшив content box с помощью изменения значения свойства box-sizing.

Перестал вмещаться контент? Замени у родителя и потомка свойство height на min-height. */

.parent {
  width: 200px;
  min-height: 150px;
  padding: 1rem;
  background-color: teal;
  box-sizing: border-box;
}

.child {
  min-height: 150px;
  background-color: goldenrod;
}

/* Theory
  нельзя задать значение в процентах только для border;
для padding и margin процент берется только от значения width вне зависимости от того какой из сторон задается значение;
width берет проценты от ширины родительской width;
height берет проценты от высоты родительской height.
  Задание
Для элемента с классом child задайте с помощью процентов
ширину в половину от ширины родительского элемента;
высоту в половину от высоты родительского элемента;
padding-left в процентах (чтобы получился эквивалент 20px);
margin-top в процентах (чтобы получился эквивалент 40px).
Т.к. высота в процентах отсчитывается только от заданной высоты, то замени свойство min-height у элемента с классом parent на свойство height. */

.parent {
  width: 200px;
  height: 300px;
  background-color: teal;
  box-sizing: border-box;
}

.child {
  border: 1px solid #fff;
  width: 50%;
  height: 50%;
  padding-left: 10%;
  margin-top: 20%;
  background-color: goldenrod;
}

.inner {
  background: red;
  height: 100%;
}

/* Задание
Для элемента с классом parent задай верхнюю границу в 1px стиля solid прозрачного (transparent) цвета.

Убедитесь, что выпадение вертикального отступа исчезло. */


.parent {
  width: 200px;
  height: 300px;
  border-top: 1px solid transparent;
  background-color: teal;
  box-sizing: border-box;
}

.child {
  width: 50%;
  height: 50%;
  border: 1px solid #fff;
  padding-left: 10%;
  margin-top: 20%;
  background-color: goldenrod;
}
.inner {
  background: red;
  height: 100%;
}

/* Выпадение вертикального отступа и margin-collaps можно предотвратить, если придерживаться следующей тактики присваивания padding и margin:

родительскому элементу задавать padding вместо того, чтобы задавать дочернему элементу margin;
родительскому элементу не задавать margin-top, но задавать margin-bottom верхнему соседу.
Задание
Для элемента с классом child
удали свойство margin-top;
добавь свойство padding-top со значением 40px родительскому элементу.
Для элемента с классом parent добавь нижний отступ в 20px.

Обрати внимание, что никаких побочных эффектов от применения вертикальных значений margin не наблюдается. */

.parent {
  width: 200px;
  height: 300px;
  background-color: teal;
  box-sizing: border-box;
  padding-top: 40px;
  margin-bottom: 20px;
}

.child {
  width: 50%;
  height: 50%;
  border: 1px solid #fff;
  margin-left: auto;
  margin-right: auto;
  background-color: goldenrod;
}

/* Задание
Добейся размещения по 4 элемента с классом box в один ряд. Для этого

измени font-size элементу с классом container;
задай font-size элементу с классом box, со значением 1rem (это значение font-size задано body). */

body {
  font-size: 20px;
}
/* 
  ширина container 360  
  или 4 раза по 90  
*/
.container {
  width: 360px;
  margin: auto;
  padding-top: 15px;
  background: burlywood;
  font-size: 0;
}

/* 
  ширина box 15 + 60 + 15
  или 90  
*/
.box {
  width: 60px;
  margin: 0 15px 15px;
  height: 75px;
  line-height: 75px;
  background-color: teal;
  display: inline-block;
  text-align: center;
  color: #fff;
  font-size: 1rem;
}

/* Задание
Добейся размещения по 3 элемента с классом box в один ряд с расстоянием от края в 15px и расстоянием между соседними элементами в 30px. Для этого задай одно свойство margin со значениями

0 для верхнего отступа (его заменяет padding-top родителя);
15px для нижнего отступа;
15px для левого и правого отступа. */

body {
  font-size: 20px;
}
/* 
  ширина container 480  
  или 3 раза по 160  
*/
.container {
  width: 480px;
  margin: auto;
  padding-top: 15px;
  background: burlywood;
  font-size: 0;
}

/* 
  ширина box x + 130 + x
  или 160  
*/
.box {
  width: 130px;
  height: 75px;
  line-height: 75px;
  background-color: teal;
  display: inline-block;
  text-align: center;
  color: #fff;
  font-size: 1rem;
  margin: 0 15px 15px;
}

/* Задание
Добейся размещения по 3 элемента с классом box в один ряд с расстоянием от края в 0 и расстоянием между соседними элементами в 30px (сумма margin-left и margin-right). Для этого задай

margin-left: 0 для 1-го, 4-го, 7-го и 10-го элемента;
margin-right: 0 для 3-го, 6-го, 9-го и 12-го элемента;
margin-bottom: 0 для 10-го, 11-го и 12-го элемента. */

body {
  font-size: 20px;
}

/* 
  2 * 15 - это размер, 
  который box-sizing: border-box 
  отнял у width и height

  ширина container 480  - (2 * 15)
  или 3 раза по 160 - (2 * 15)  
*/
.container {
  width: 480px;
  margin: auto;
  padding: 15px;
  background: burlywood;
  font-size: 0;
  box-sizing: border-box;
}

/* 
  ширина box x + 130 + x
  или 160  
  за исключением крайних элементов
*/
.box {
  width: 130px;
  margin: 0 15px 15px;
  height: 75px;
  line-height: 75px;
  background-color: teal;
  display: inline-block;
  text-align: center;
  color: #fff;
  font-size: 20px;

}

.box:nth-of-type(3n+1) {
  margin-left: 0;
}

.box:nth-of-type(3n) {
  margin-right: 0;
}

.box:nth-last-of-type(-n+3) {
  margin-bottom: 0;
}


/* BLOCK 6 */

/* Задание
Добейся размещения 3-х элементов с классом box в один ряд с расстоянием между соседними элементами в 30px без использования margin. Для этого задай элементу с классом container свойства с подходящими значениями
display для того чтобы flex модель применилась к потомкам;
justify-content для добавления равных отступов между блоками.
Размести текст (цифру) по центру элемента с классом box. Для этого задай элементу с классом box подходящие значения свойствам
display для того чтобы flex модель применилась к потомку - тексту;
justify-content для центрирования по горизонтали ;
align-items для центрирования по вертикали. */

body {
    font-size: 20px;
  }
  
  /* 
    2 * 15 - это размер, 
    который box-sizing: border-box 
    отнял у width и height
  
    ширина container 480  - (2 * 15)
    или 3 раза по 160 - (2 * 15)  
  */
  .container {
    display: flex;
    justify-content: space-between;
    width: 480px;
    margin: auto;
    padding: 15px;
    background: burlywood;
    box-sizing: border-box;
  }
  
  .box {
    display:flex;
    justify-content: center;
    align-items: center;
    width: 130px;
    min-height: 75px;
    background-color: teal;
    color: #fff;
  }

  
  /* Задание
У элемента с классом container padding-left и padding-right равны 0.

Добейся размещения 3-х элементов с классом box в один ряд с расстоянием между соседними элементами в 30px и по 15px по краям, без использования margin.

Для этого задай элементу с классом container подходящее значение для свойства justify-content. */

body {
    font-size: 20px;
  }
  
  /* 
    ширина container 480 
    или 3 раза по 160   
  */
  .container {
    justify-content: space-around;
    width: 480px;
    margin: auto;
    padding: 15px 0;
    background: burlywood;
    box-sizing: border-box;
    display: flex;
  }
  
  .box {
    width: 130px;
    min-height: 75px;
    background-color: teal;
    color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  /* Задание
Добейся размещения по 3 элемента классом box в один ряд с расстоянием между соседними элементами в 30px без использования margin. И с нижним отступом в 15px.
Для этого задай

элементу с классом container свойство flex-wrap со значением для переноса потомков на новую строку;
элементу с классом box свойство margin-bottom со значением отступа.
Обрати внимание, что у элемента с классом container значение свойства padding в 15px применятся к трем сторонам и не применятся к padding-bottom. */

body {
    font-size: 20px;
  }
  
  .container {
    flex-wrap: wrap;
    width: 480px;
    margin: auto;
    padding: 15px 15px 0;
    background: burlywood;
    box-sizing: border-box;
    display: flex;
    justify-content: space-between;
  }
  
  .box {
    width: 130px;
    min-height: 75px;
    margin-bottom: 15px;
    background-color: teal;
    color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  /* Задание
Добейся размещения в один ряд элементов внутри header. При этом элемент logo должен быть в левом углу, а меню - в правом.
Для этого задай элементу с классом container

display для того чтобы flex модель применилась к потомкам;
свойство justify-content для размещения элементов по краям родительского элемента;
свойство align-items для центрирования элементов по вертикали;
элементу с классом nav-menu  задай свойство display для того, чтобы flex модель применилась к потомкам. */

a {
    text-decoration: none;
  }
  
  .container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    max-width: 480px;
    margin: auto;
    padding: 15px;
    background: burlywood;
    box-sizing: border-box;
  }
  
  .nav-menu {
    display: flex;
    list-style: none;
  }
  
  .nav-menu_link {
    margin: 0 15px;
  }

  /* Задание
Добейся размещения элемента с классом box-left в левом углу, не меняя положения элементов, расположенных в правом углу.
Для этого задай элементу с классом box-left подходящее свойство margin с нужным значением. */

body {
    font-size: 20px;
  }
  
  /* 
    ширина container 480 
    или 3 раза по 160   
  */
  .container {
    width: 90%;
    margin: auto;
    padding: 15px 0;
    background: burlywood;
    box-sizing: border-box;
    display: flex;
    justify-content: flex-end;
  }
  
  .box {
    width: 130px;
    min-height: 75px;
    background-color: teal;
    color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 0 15px
  }
  
  .box-left {
  margin-right: auto;
  }

  /* BLOCK 7 */

  /* Задание
Заполните элемент с классом container фоновым изображением (свойство background-image), которое расположено по ссылке ./hands-typing.jpg. Изображение должно заполнить всю высоту элемента (свойство background-size) и находиться по центру (свойство background-position). */

.container {
  max-width: 200px;
  height: 240px;
  margin: auto;
  background-color: hsla(0,0%,0%,.1);
  background-image: url('./hands-typing.jpg');
  background-size: cover;
  background-position: center;
}

/* Задание
Элемент с классом container имеет фоновое изображение, которое находиться по центру (свойство background-position) .

Изображение должно заполнить всю ширину элемента (свойство background-size) и не повторяться (свойство background-repeat). */

.container {
  max-width: 200px;
  height: 240px;
  margin: auto;
  background-color: hsla(0, 0%, 0%, 0.1);
  background-image: url(./hands-typing.jpg);
  background-position: center;
  background-repeat: no-repeat;
  background-size: contain;
}


/* Задание
Элемент с классом container-fluid имеет фоновое изображение, которое находится по центру (свойство background-position) и не повторяeтся (свойство background-repeat).

Изображение должно заполнить всю высоту и, насколько это возможно, всю ширину элемента (свойство background-size). */
.container-fluid {
  height: 200px;
  background-size: cover;
  background-image: url(./hands-typing.jpg);
  background-repeat: no-repeat;
  background-position: center;
}

.container {
  max-width: 480px;
  height: 100%;
  margin: auto;
  padding-top: 2rem;
  box-sizing: border-box;
  text-align: center;
  color: #fff;
  background-color: hsla(0, 0%, 0%, 0.1);
}

/* Задание
В html есть элементы с атрибутом data-clip с разными значениями. Эти атрибуты выступают в качестве селекторов.

Примени значения атрибута data-clip в качестве значения для свойства background-clip. Для свойства text используй запись с вендорным префиксом и только затем обычную запись правила.

Обрати внимание на то, как изменяется отображение фона (цвета и изображения) в элементе. */

<ul class="items">
  <li class="item"></li>  
  <li class="item" data-clip="padding-box"></li>  
  <li class="item" data-clip="content-box"></li>  
  <li class="item text" data-clip="text">
    Текст
  </li>  
</ul>  

.text {
  font-size: 48px;
  font-weight: 800;
  text-align: center;
  color: transparent;
}
.items {
  list-style: none;
  display: flex;
  flex-wrap: wrap;
}
.item {
  width: 240px;
  height: 100px;
  box-sizing: border-box;
  padding: 10px;
  border: 10px dashed orangered;
  margin: 0 auto 1rem;
  background-color: hsla(0, 0%, 0%, .1);
  background-image: url(./hands-typing.jpg);
  background-size: contain;
  background-position: center;
  background-repeat: no-repeat;
  
}
[data-clip="padding-box"] {
  background-clip: padding-box;
}
[data-clip="content-box"] {
  background-clip: content-box;
}
[data-clip="text"] {
  -webkit-background-clip: text;
  background-clip: text;
}

/* Изображение img
Замещаемый строчный элемент

Тег img имеет два обязательных атрибута - src и alt. Атрибут alt содержит текст и в силу того что файл html загружается раньше, чем файлы, содержащиеся в ссылках кода html, текст будет отображен первым.

Затем браузер подгрузит изображение по ссылке src и заменит (заместит) текст изображением. Это создает множество нежелательных побочных эффектов.

В этом задании мы рассмотрим прием, который избавляет от ряда таких нежелательных эффектов. Суть приема заключается в размещении изображения внутри блочного элемента и изменения у изображения значения display с inline на block.

Задание
Изображение размещается внутри элементов с классом wrp-image для которого задан размер меньший, чем размер изображения. У изображения есть класс images. Размести изображение внутри элемента с классом wrp-image так, чтобы изображение занимало 100% ширины родительского элемента и не имело отступа с border-bottom.

Для этого создай правило css с селектором-классом images и двумя свойствами:

width;
display. */

.container {
  display: flex;
  padding-top: 15px;
}
.wrp-image {
  width: 240px;
  border: 1px solid gold;
  margin: 0 15px 15px;
} 

.images {
  width: 100%;
  display: block;
}

/* Задание
Элементу img надо задать размер меньший, чем размер изображения, и, к тому же, в другой пропорции. При этом необходимо сохранить пропорции изображения ценой того, что часть фотографии не будет отображаться.

Для этого задай элементу с классом images

свойство width со значением 240px;
свойство height со значением 320px;
свойство object-fit со значением cover. */

.container {
  display: flex;
  padding-top: 15px;
}
.images {
  border: 1px solid gold;
  margin: 0 15px 15px;
  width: 240px;
  height: 320px;
  object-fit: cover;
}

/* Псевдоэлементы
Псевдоэлементы имеют такой же приоритет, как и элементы (теги) в качестве селекторов.

Псевдоэлемент ::before по умолчанию имеет значение inline свойства display и находится перед элементом.

Псевдоэлемент ::after по умолчанию имеет значение inline свойства display и располагается после элемента.

Обязательным для пслевдоэлементов является свойство content.

Если в качестве значения свойства content используется юникод, то синтаксис юникода должен быть в формате для css, а не для html.

Задание
Есть спецсимвол для открывающей кавычки (\275D) и для закрывающей (\275E).

Для класса cite задайте два css свойства с псевдоэлементами ::before и ::after так, чтобы текст внутри элемента с классом cite на веб-странице был обернут в кавычки - вначале открывающей и в конце закрывающей. */

<p class="cite">Кавычки для цитаты</p>

.cite::before {
  content: '\275D';
}

.cite::after {
  content: '\275E';
}

/* NOTE TO SASHA: Синтаксис линейного градиента должен обязательно содержать цвет и необязательные параметры: - tangled/confusing (ex. 8 in block 7) */

/* Задание
Задан линейный градиент для фона элемента body. Т.к. в html документе нет контента, то надо задать высоту. Напомним, что высота элементов и body в том числе, всегда определяется высотой контента. Но блочным элементам высоту можно задать.

Добавь к значениям свойства linear-gradient дополнительно:

направление и угол фона в -45deg;
75% длины для цвета hsl(270, 100%, 30%). */

body { 
  min-height: 100vh;
  background: linear-gradient(
    -45deg,
      hsl(0, 100%, 30%), 
      hsl(270, 100%, 30%) 75%
    );
  }

  /* Линейный градиент.
Перечисление градиентов и повтор линейного градиента.

К одному фону можно применить несколько линейных градиентов, перечисляя их через запятую. При этом градиенты могут пересекаться и накладываться один на другой. Например:

<div class="box"></div>
.box {
  width: 200px;
  height: 100px;
  background: 
  linear-gradient(90deg,
      red 50px,  transparent 50px 100%) ,
  linear-gradient(
      orange 50px, transparent 50px 100%);
     ;
}
Если есть необходимость в повторении линейного градиента в фоне, то можно использовать другое свойство - repeating-linear-gradient. Пример:

<div class="container"></div>
.container {
  width: 200px;
  height: 100px;
  background: repeating-linear-gradient(
      orange 1px, transparent 2px, transparent 20px);
     ;
}
Перечисление нескольких линейных градиентов применимо и к repeating-linear-gradient. Рассмотрим этот случай в задании.

Задание
Фон body оформлен в виде листа в линейку. Оформи фон в виде листа в клеточку. Для этого

через запятую добавь то же самое свойство  repeating-linear-gradient;

используй то же самое значение, добавив к нему только поворот на 90deg. */

body {
  min-height: 100vh;
  background: 
    repeating-linear-gradient(
      #bbb 1px, transparent 2px, transparent 28px), 
    repeating-linear-gradient( 90deg, #bbb 1px, transparent 2px, transparent 28px);
  
}
  

/* TO SASHA: ex 10 block 7: Тень элемента
Значения box-shadow имеет два варианта (для внешней и внутренней тени):

смещение-по-x смещение-по-y размытие распространение цвет. -wtf? */

/* Тень элемента
Значения box-shadow имеет два варианта (для внешней и внутренней тени):

смещение-по-x смещение-по-y размытие распространение цвет.
inset смещение-по-x смещение-по-y размытие распространение цвет.
Где

Смещение-по-x (x-offset) означает смещение тени по горизонтали относительно блока. Может принимать как положительные, так и отрицательные значения, положительное - смещает тень вправо от блока, отрицательное – влево. Обязательное значение.
Смещение-по-y (y-offset) означает смещение тени по вертикали относительно блока. Может принимать как положительные, так и отрицательные значения, положительное - смещает тень вниз, отрицательное - вверх. Обязательное значение.
Размытие (blur) определяет радиус размытия тени. Чем больше радиус, тем сильнее размыта тень. Можно использовать только положительные значения. Необязательное значение.
Распространение (spread) расширяет тень, утолщая ее. Принимает как положительные, так и отрицательные значения. Необязательное значение.
Цвет (color) необязательное значение. По умолчанию тень черного цвета. Для задания значения можно использовать hex, rgb, rgba форматы записи цвета.
inset - создаёт тень внутри блока.
Задание
Элементу button с классом btn задано свойство box-shadow.

Необходимо добавить также это свойство с другими значениями для события hover и focus и отдельно для события active. Для этого:

в коде css добавь свойство box-shadow к уже готовым селекторам с псевдоклассами состояний hover, focus и active;
для hover и focus значения смещение-по-x, смещение-по-y, размытие и распространение равны 1px, а цвет - черный с прозрачностью в .3, т.е. hsla(0,0%,0%,.3);
для active значения смещение-по-x, смещение-по-y, размытие и распространение равны 3px, а цвет - черный с прозрачностью в .3, т.е. hsla(0,0%,0%,.3). Также для active тень должна быть внутренней, т.е. с использованием значения inset; */

.controls {
  padding: 1rem;
  text-align: center;
}
.btn {
  padding: .5rem 1.75rem;
  border: none;
  background: linear-gradient( hsl(120, 100%, 35%) , hsl(120, 100%, 20%));
  color: #fff;
  font-size: 20px;
  cursor: pointer;
  box-shadow: 3px 3px 3px 3px hsla(0,0%,0%,.1);
}
.btn:hover,
.btn:focus {
   box-shadow: 1px 1px 1px 1px hsla(0,0%,0%,.3);
}

.btn:active {
   box-shadow: inset 3px 3px 3px 3px hsla(0,0%,0%,.3);

}

/* Задание
<svg aria-hidden="true" style="position: absolute; width: 0; height: 0"
  xmlns="http://www.w3.org/2000/svg" overflow="hidden">
  <defs>
    <symbol id="icon-pen" viewBox="0 0 32 32">
      <path d="M12 20l4-2 14-14-2-2-14 14-2 4zM9.041 27.097c-0.989-2.085-2.052-3.149-4.137-4.137l3.097-8.525 4-2.435 12-12h-6l-12 12-6 20 20-6 12-12v-6l-12 12-2.435 4z"></path>
    </symbol>
    <symbol id="icon-search" viewBox="0 0 32 32">
      <path  d="M31.008 27.231l-7.58-6.447c-0.784-0.705-1.622-1.029-2.299-0.998 1.789-2.096 2.87-4.815 2.87-7.787 0-6.627-5.373-12-12-12s-12 5.373-12 12 5.373 12 12 12c2.972 0 5.691-1.081 7.787-2.87-0.031 0.677 0.293 1.515 0.998 2.299l6.447 7.58c1.104 1.226 2.907 1.33 4.007 0.23s0.997-2.903-0.23-4.007zM12 20c-4.418 0-8-3.582-8-8s3.582-8 8-8 8 3.582 8 8-3.582 8-8 8z"></path>
    </symbol>
    <symbol id="icon-delete" viewBox="0 0 32 32">
      <path d="M6 32h20l2-22h-24zM20 4v-4h-8v4h-10v6l2-2h24l2 2v-6h-10zM18 4h-4v-2h4v2z"></path>
    </symbol>
  </defs>
</svg>
В html документе, внутри элемента div, размещены три svg иконки из спрайта. Задай цвет изображениям svg по цвету текста родительского элемента div. Цвет иконок должен меняться на orangered и при наведении курсора на div.

Для этого

селектору класса icon задай css свойство fill со значением currentColor;
Убедись, что цвет иконок меняется вместе с цветом текста также и при наведении курсора на элемент div. */

div {
  color: green;
  background-color: #eee;
  font-size: 24px;
}

.icon {
  display: inline-block;
  width: 2rem;
  height: 2rem;
  fill: currentColor;

}

div:hover {
  color: orangered;
}

/* Для svg спрайтов используется следующий прием. Селектору задается css переменная со значением currentColor, что означает текущий цвет родителя. Затем эта переменная переносится в спрайт и добавляется атрибуту fill вместе со значением по умолчанию. Например :

.icon {
  --color: currentColor;
}
Спрайт:

<path fill="var(--color, #000)" d="M12 20l4-2 14-14-2-2-14 14-2 4zM9.041 27.097c-0.989-2.085-2.052-3.149-4.137-4.137l3.097-8.525 4-2.435 12-12h-6l-12 12-6 20 20-6 12-12v-6l-12 12-2.435 4z"></path>   
Задание
<svg aria-hidden="true" style="position: absolute; width: 0; height: 0"
  xmlns="http://www.w3.org/2000/svg" overflow="hidden">
  <defs>
    <symbol id="icon-pen" viewBox="0 0 32 32">
      <path fill="var(--icon-color, #000)" d="M12 20l4-2 14-14-2-2-14 14-2 4zM9.041 27.097c-0.989-2.085-2.052-3.149-4.137-4.137l3.097-8.525 4-2.435 12-12h-6l-12 12-6 20 20-6 12-12v-6l-12 12-2.435 4z"></path>
    </symbol>
    <symbol id="icon-search" viewBox="0 0 32 32">
      <path fill="var(--icon-color, #000)" d="M31.008 27.231l-7.58-6.447c-0.784-0.705-1.622-1.029-2.299-0.998 1.789-2.096 2.87-4.815 2.87-7.787 0-6.627-5.373-12-12-12s-12 5.373-12 12 5.373 12 12 12c2.972 0 5.691-1.081 7.787-2.87-0.031 0.677 0.293 1.515 0.998 2.299l6.447 7.58c1.104 1.226 2.907 1.33 4.007 0.23s0.997-2.903-0.23-4.007zM12 20c-4.418 0-8-3.582-8-8s3.582-8 8-8 8 3.582 8 8-3.582 8-8 8z"></path>
    </symbol>
    <symbol id="icon-delete" viewBox="0 0 32 32">
      <path fill="var(--icon-color, #000)" d="M6 32h20l2-22h-24zM20 4v-4h-8v4h-10v6l2-2h24l2 2v-6h-10zM18 4h-4v-2h4v2z"></path>
    </symbol>
  </defs>
</svg>
В файле sprite-with-fill.svg используется css переменная --icon-color. Сделай так, чтобы svg иконка с классом link-icon меняла цвет вместе с цветом текста ссылки элемента с классом link.

Для этого в селекторе link-icon объяви переменную --icon-color и задай этой переменной значение, при котором бы наследовался цвет от родителя . */

.link {
  text-decoration: none;
  color: green;
  font-family: sans-serif;
  font-size: 24px;
  display: flex;
  align-items: center;
}
.link-icon {
  margin-right: 0.5rem;
  --icon-color: currentColor;
}
.link:hover {
  color: orangered;
}

/* SVG
Смена фона для sprite иконок

Иконки, как правило, имеют прозрачный фон. Поэтому, в качестве фона, используется фон ближайшего родительского элемента. Поэтому, нет необходимости изменять фон для sprite - достаточно позаботиться о смене цвета для иконок, а фон менять только у родительского элемента.

Задание
Задайте hover для смены цвета svg иконок и фона.

Для этого:

селектору класса link задайте цвет текста с помощью переменной --accent;

селектору класса link-icon  задайте переменную --icon-color со значением, необходимым для получения цвета текста родительского элемента;

селектору класса link c псевдоклассом :hover задайте цвет текста с помощью переменной --primay; */

:root {
  --primay: burlywood;
  --accent: cadetblue;
}
.items {
  list-style: none;
  display: flex;
}
.item {
  margin: .25rem;
}
.link {
  display: block;
  padding: 0.5rem;
  border-radius: 50%;
  background-color: var(--primay);
  color: var(--accent);

}
.link-icon {
  --icon-color: currentColor;

}
.link:hover {
  background-color: var(--accent);
  color: var(--primay);
  
}

/* BLOCK 9 */

/* Задание
Элемент с классом box надо переместить вниз и вправо на 50%. Для этого

измени свойство position на absolute;
задай начало отсчета и направление с помощью свойств left и top со значением в 50%;
Убедись что

смещение происходит относительно левого верхнего угла элемента, т.к. именно он попадает в заданную точку - центр прямоугольника;
при смещении элемента, вместе с ним перемещаются его потомки: элемент span и текст. */

.container {
  width: 480px;
  height: 240px;
  margin: 1rem auto;
  background: 
  /* верхний фон */
  linear-gradient(26.3deg, 
  /* черный прозрачностью .2 */
    hsla(0, 0%, 0%, .2), 
    hsla(0, 0%, 0%, .2) 50%, 
    transparent 50%, 
    transparent),
    /* нижний фон */
  linear-gradient(153.3deg,
    teal, 
    teal 50%, 
    slategray 50%, 
    slategray);
  position: relative;
}

.box {
  position: absolute;
  left: 50%;
  top: 50%;
  --size: 50px;
  width: var(--size);
  height: var(--size);
  background-color: orange;
  display: flex;
  /* Напиши код под этой строкой */

}

/*
  центрируем элемент при
  родителе под flex
 */
span {
  margin: auto;
}

/* Задание
Для двух элементов, расположенных среди других элементов, задайте смещение вниз и вправо на 2rem. Для этого:

Для элемента с классом by-position задайте свойство position: relative и затем осуществите смещение свойствами top и left.

Для элемента с классом by-margin осуществите смещение свойствами margin-top и margin-left.

Убедись, что элемент со свойством position: relative при смещении не изменил положение соседних элементов. */

body {
  font-family: sans-serif;
}
h2 {
  text-align: center;
}
.container-fluid {
  display: flex;
  justify-content: space-between;
}
.container {
  width: 350px;
  margin: .5rem auto;
  padding: .75rem .5rem .25rem;
  border-radius: 1rem;
  background-color: teal;

  /* удаляем пробелы между inline-block */
  font-size: 0;
}
.box {
  display: inline-block;
  width: 100px;
  margin: 0 .5rem .5rem;
  border-radius: .5rem;
  color: #fff;
  background-color: orange;

  /* восстанавливаем видимость текста */
  font-size: 18px;
  
  /* центрируем текст */
  --h: 2rem;
  height: var(--h);
  line-height: var(--h);
  text-align: center;
}

/* Напиши код под этой строкой */
.by-position {
  position: relative;
  top: 2rem;
  left: 2rem;
  background-color: palevioletred;

}
.by-margin {
  margin-top: 2rem;
  margin-left: 2rem;
  background-color: lightskyblue;

}

/* Задание
Для двух элементов, расположенных среди других элементов, задайте смещение на 2rem на все 4-ре стороны. Для этого:

Для элемента с классом by-position задайте свойство position: relative и затем осуществите смещение свойствами top, left, bottom и right.

Для элемента с классом by-margin осуществите смещение свойством margin и значением 2rem.

Убедись, что элемент со свойством position: relative при смещении проигнорировал значения bottom и right. */

body {
  font-family: sans-serif;
}
h2 {
  text-align: center;
}
.container-fluid {
  display: flex;
  justify-content: space-between;
}
.container {
  width: 350px;
  margin: .5rem auto;
  padding: .75rem .5rem .25rem;
  border-radius: 1rem;
  background-color: teal;
  display: flex;
  justify-content: space-around;
  flex-wrap: wrap;
}
.box {
  width: 100px;
  margin: 0 .5rem .5rem;
  border-radius: .5rem;
  color: #fff;
  background-color: orange;
  font-size: 18px;
  
  /* центрируем текст */
  --h: 2rem;
  height: var(--h);
  line-height: var(--h);
  text-align: center;
}

.by-position {
  position: relative;
  top: 2rem;
  left: 2rem;
  right: 2rem;
  bottom: 2rem;
  background-color: palevioletred;

}
.by-margin {
  margin: 2rem;
  background-color: lightskyblue;

}

/* Задание
В html коде есть элементы с атрибутом id и значениями up и down. На каждый такой элемент создана ссылка - с классом up и якорем href="#up", и классом down и якорем href="#down". Эти ссылки используются для навигации по странице - перехода к элементам с соответствующим id по клику на ссылку.

Размести ссылки так, чтобы при вертикальной прокрутке окна браузера ссылки оставались неподвижными на своих местах (одна - в верхнем, вторая - в нижнем углу в 3rem от краев).

Для этого:

элементу с классом up задай свойства top и left со значением 3rem;
элементу с классом down задай свойства bottom и right со значением 3rem;
элементу с классом page-nav задай свойства position с подходящим значением. */

:root {
  --s: 50px;
}

body {
  font-size: 24px;
  text-align: center;
  font-family: sans-serif;
  background: linear-gradient(hsl(189, 100%, 85%), hsl(224, 75%, 25%));
}

main {
 height: 200vh;
}

footer {
  color: #fff
}

a {
  width: var(--s);
  height: var(--s);
  line-height: var(--s);
  text-decoration: none;
  font-size: 36px;
  display: inline-block;
  color: #fff;
  border-radius: 1rem;
  background-color: firebrick;
}

/* Напиши код под этой строкой */
.page-nav {
  position: fixed;

}

.up {
  top: 3rem;
  left: 3rem;

}

.down {
  bottom: 3rem;
  right: 3rem;

}

/* Задание
Элемент с классом modal надо разместить на всю ширину и высоту экрана с темным полупрозрачным фоном. По центру этого элемента надо разместить другой элемент с классом box. Для этого элементу с классом modal:

Удали у свойства display значение none. Это разместит modal в DOM и браузер начнет применять css свойства.

Добавь свойству display значение flex. Тогда потомок - элемент с классом box имея значение margin: auto будет находиться по центру родительского элемента.

Задай черный полупрозрачный цвет фону с помощью background-color: hsla(0, 0%, 0%, .5);.

Задай свойство position и значение fixed.

Растяни элемент на всю ширину экрана, задав свойствам left, rigth, top и bootom значение 0.

Отцентрируй элемент с селектором класса box, задав свойство margin со значением auto. Обрати внимание, что если элемент находится под действием родительского свойства flex, то свойство auto выравнивает не только по ширине, но и по высоте родительского элемента.

Обрати внимание на то что ссылка находится под элементом с классом modal и в результате стала недоступной для клика. */

body {
  height: 200vh;
  background: linear-gradient(hsl(189, 100%, 85%), hsl(224, 75%, 25%));
  text-align: center;
}

.box {
  padding: 2rem 1rem;
  box-sizing: border-box;
  width: 360px;
  height: 200px;
  background-color: #fff;
  cursor: initial;
/* Добавь свойство под этой строкой */
  margin: auto;
}
  

.btn,
.box {
  cursor: pointer;
}

.modal {
  cursor: not-allowed;
/* Измени код под этой строкой */
  display: flex;
  left: 0;
  right: 0;
  bottom: 0;
  top: 0;
   background-color: hsla(0, 0%, 0%, .5);
  position: fixed;
}

/* Position: sticky.
Неподвижный header
Техника неподвижный header основана на том CSS правиле position: fixed, что и при создании модального окна. Но в технике неподвижный header используется ряд отличий:

не задается значение свойству bottom;
элементу задается высота;
элементу задается z-index больше, чем у других элементов, например больше чем у элементов с position: sticky.
Sticky (липкий)
Значение sticky свойства position:

соединяет поведение элементов при значениях fixed и absolute;
поддерживает только свойство top, т.е. не поддерживается bottom, left и right;
свойство top требует обязательно задать начальное значение (например 0).
Задание
Есть несколько списков с названиями тегов. У каждого списка первым элементом идет li с классом letter и текстом, содержащим букву, с которой начинается теги в этом списке. Надо сделать так, чтобы при прокрутке списков вниз буква каждого списка прижималась к header и оставалась в таком положении до тех пор, пока теги из этого списка видны на экране.

Для этого элементам с классом letter:

добавь свойство position со значением sticky;
задай обязательное начальное значение top по высоте header (т.е. 40px);
убедись в том что элементы с классом letter при некоторых условиях ведут себя как position со значением fixed. */

.container {
  padding-top: 40px;
  width: 480px;
  margin: auto;
}

header {
  display: flex;
  margin: 0;
  font-family: sans-serif;
  background-color: #fff;
  box-shadow: 2px 2px 6px 3px hsla(0, 0%, 0%, .2);

/* Неподвижный header */
  position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 40px;
    z-index: 20;
}

h1 {
  margin: auto;
}

.letter {
  height: 2rem;
  margin-left: 10rem;
  margin-right: 10rem;
  border-radius: 3px;
  list-style-type: none;
  line-height: 2rem;
  text-align: center;
  color: #d00;
  background: navajowhite;
  /* Напиши код под этой строкой */
  position: sticky;
  top: 40px;

}

/* Absolute
Положение элемента с position: absolute
Если не заданы top, right, bottom или left, то элемент занимает верхний левый угол контентной области родителя (т.е. такой элемент будет учитывать padding или border ближайшего родительского элемента).

Если какое-то значение из top, right, bottom или left задано, то от сторон ближайшего предка с position отличным от static (элемент не будет учитывать padding или border).

Если нет предков с position, отличным от static, то отсчет ведется от body.

Относительные размеры у элементов с position: absolute
Размеры элемента с position: absolute, заданные в относительных единицах зависят от контекста (от размеров ближайшего relative элемента).

Задание
Задай элементам с классом box свойство top со значением 0 и убедись в том что элементы нашли ближайшего предка с position: relative или body и расположились в нем как в родительском элементе.

Задай элементам с классом box свойство width со значением 100%
и убедись в том что элементы заняли всю ширину своего нового родительского элемента с position: relative или body . */

:root {
  --s: 1.5rem;
}
* {
  margin: 0;
  padding: 0;
}
body {
  padding-top: 1rem;
}
.container-outer {
  margin: 1rem 0 0;
  padding: .5rem 0;
  width: 75%;
  background-color: mediumseagreen;
}
.container {
  background-color: slateblue;
  padding: .5rem 0;
  width: 50%;
  height: var(--s);
}
.psr {
  position: relative;
}
.box {
  border-radius: 2rem;
  height: var(--s);
  line-height: var(--s);
  background-color: crimson;
  text-align: center;
  position: absolute;
  /* Напиши код под этой строкой */
  top: 0;
  width: 100%;

}

/* z-index
z-index изменяет положение элемента по оси Z, где ось Z - линия перпендикулярная экрану монитора.

Значение z-index по умолчанию не задано (условно равно 0) для всех элементов.

Для свойства z-index допустимы отрицательные значения.

Запомнить:
z-index действует на соседей.
z-index не действует на потомков.
Задание
Надо изменить порядок отображения элементов по оси, перпендикулярной экрану монитора. При этом надо убедиться, что z-index не действует на потомков.

Для этого:

Элементу с классом inner задай свойство z-index: 100 и убедись, что эти элементы не перекрываются никакими другими элементами (т.к. у всех остальных элементов значение z-index не задано).

Расположите элементы с классом alfa, beta и gamma в таком порядке

alfa выше всех соседей, со значением 30 свойства z-index;
beta находится по средине, со значением 20 свойства z-index;
gamma ниже всех соседей, со значением 10 свойства z-index.
Убедитесь, что элементы с классом inner теперь частично перекрыты, т.е. z-index не действует на потомков. */

.box {
  display: flex;
  --s: 60px;
  width: var(--s);
  height: var(--s);
  border-radius: 50%;
  position: absolute;
}
.inner {
  margin: auto;
  --s: 30px;
  width: var(--s);
  height: var(--s);
  border-radius: 50%;
  background-color: orange;
  z-index: 100;

}
.alfa {
  background-color: crimson;
  top:30px;
  left: 5px;
  z-index: 30;

}
.beta {
  background-color: slateblue;
  left: 25px;
  z-index: 20;

}
.gamma {
  top:30px;
  left: 45px;
  background-color: mediumseagreen;
  z-index: 10;

}

/* BLOCK 10 */

/* Задание
Элемент с классом box надо разместить по центру родительского элемента. Для этого используй смещение на 50%, с помощью свойства position, со значением absolute, а также свойство transform со значением translate и смещением по горизонтали и вертикали в -50%; */

.container {
  width: 480px;
  height: 240px;
  margin: 16px auto;
  background:
  /* верхний фон */
  linear-gradient(26.3deg,
  /* черный прозрачностью .2 */
    hsla(0, 0%, 0%, .2),
    hsla(0, 0%, 0%, .2) 50%,
    transparent 50%,
    transparent),
    /* нижний фон */
  linear-gradient(153.3deg,
    teal,
    teal 50%,
    slategray 50%,
    slategray);
  position: relative;
}

.box {
  --size: 50px;
  width: var(--size);
  height: var(--size);
  background-color: orange;
  display: flex;
  /* Напиши код под этой строкой */
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

/*
  центрируем элемент при
  родителе под flex
 */
span {
  margin: auto;
}

/* Задание
Наведи курсор на элемент (красный круг) и убедись что при hover CSS переход есть.
Уведи курсор от элемента и убедись, что CSS переход не работает при отводе курсора.
Сделай CSS переход симметричным, т.е. чтобы переход происходил как при наведении курсора на элемент, так и при отводе курсора с элемента. Для этого:

перемести строку transition: .8s all ease; из селектора .box:hover  в селектор .box;
убедись что после перемещения CSS переход симметричен относительно события hover. */

body {
  text-align: center;
  font-family: sans-serif;
}

.box {
  display: inline-block;
  --r: 90px;
  width: var(--r);
  height: var(--r);
  border-radius: 50%;
  background: crimson;
  cursor: pointer;
/* Измени код под этой строкой */
  transition: .8s all ease;
}

.box:hover {

  border-radius: 0;
  background: slateblue;
}

/* Задание
При наведении курсора на текст ссылки происходит CSS переход (подчеркивание). CSS переход начинается и заканчивается с левой стороны как при наведении, так и при отводе курсора. Сделай так, чтобы CSS переход начинался с левой стороны при наведении, но при отводе курсора заканчивался с правой стороны.

Для этого расставь свойства left и right со значением 0 в подходящих селекторах. */


ul {
  display: flex;
  list-style: none;
}
li {
  margin: 0 1rem;
  position: relative;
}

a {
  display: block;
  padding-bottom: 10px;
  text-align: center;
  text-transform: uppercase;
  text-decoration: none;
  font-family: sans-serif;
  color: #f38181;
}
a::after {
  content:"";
  width: 0;
  height: 2px;
  position: absolute;
  bottom: 0;
  background: #f38181;
  transition: width .5s, left .5s;
  right: 0;
}

a:hover::after {
  width: 100%;
  left: 0;
}

/* Задание
В html для элементов с классом row заданы классы с описанием двух анимаций. В css коде селекторам с классом анимации задано свойство animation-name с соответствующим значением из описания анимации @keyframes fadeInFromLeft и @keyframes fadeInFromRight.

В перечислении селекторов .fadeInFromLeft, .fadeInFromRight записаны неверные свойства анимации.

Измените эти значения на:

1000ms для длительности анимации;
1 для количества повторов анимации;
both для определения когда (в начале или конце) будет применен первый и последний фрейм из анимации;
ease-in-out для описания функции времени у анимации;
500ms для задержки начала анимации.
Убедитесь в выполнении анимации после ввода верных значений - для этого кликните на иконку в правом углу (см. на фото)иконка для всплывающего окнаАнимация должна выполнится только один раз. */

.container {
  max-width: 480px;
  min-height: 100vh;
  margin: auto;
  padding: 1rem;
  box-shadow: 2px 2px 6px 3px hsla(0, 0%, 0%, .2);
}
.row {
  margin-bottom: 1rem;
  min-height: 60px;
}
.row:nth-of-type(2n) {
  background-color: crimson;
}
.row:nth-of-type(2n + 1) {
  background-color: slateblue;
}


@keyframes fadeInFromLeft {
  0% {
    transform: translateX(-2000px) scale(0.6);
    opacity: 0.7;
  }
  80% {
    transform: translateX(50px) scale(0.7);
    opacity: 0.7;
  }
  to {
    transform: translateX(0) scale(1);
    opacity: 1;
  }
}
@keyframes fadeInFromRight {
  0% {
    transform: translateX(2000px) scale(0.6);
    opacity: 0.7;
  }
  80% {
    transform: translateX(-50px) scale(0.7);
    opacity: 0.7;
  }
  to {
    transform: translateX(0) scale(1);
    opacity: 1;
  }
}

.fadeInFromLeft,
.fadeInFromRight  {
  animation-duration: 1000ms;
  animation-iteration-count: 1;
  animation-fill-mode: both;
  animation-timing-function: ease-in-out;
  animation-delay: 500ms;
}
.fadeInFromLeft {
  animation-name: fadeInFromLeft;
}
.fadeInFromRight {
  animation-name: fadeInFromRight;
}

/* Задание
Начальное состояние элемента - круг с цветом crimson. При hover элемент должен стать квадратом с цветом slateblue.

Есть две анимации, описывающие изменение CSS свойств при наведении курсора (cursorMoveIn) и при отводе курсора от элемента (cursorMoveOut).

Задайте краткую форму вызова анимации animation: name 0.8s forwards; в разных селекторах, заменив name на подходящее имя анимации. */

body {
  text-align: center;
  font-family: sans-serif;
}

@keyframes  cursorMoveOut {
  from {
    border-radius: 50%;
    background: crimson;
  }
  to {
    border-radius: 0;
    background: slateblue;
  }
}
@keyframes cursorMoveIn {
  from {
    border-radius: 0;
    background: slateblue;
  }
  to {
    border-radius: 50%;
    background: crimson;
  }
}

.box {
  display: inline-block;
  --r: 90px;
  width: var(--r);
  height: var(--r);
  border-radius: 50%;
  background: crimson;
  cursor: pointer;
  /* Напиши код под этой строкой */
animation: cursorMoveIn 0.8s forwards;
}

.box:hover {
animation: cursorMoveOut 0.8s forwards;
}

/* BLOCK 12 */

/* Формы. Стилизация радиокнопок и чекбоксов.
При стилизации радиокнопок и чекбоксов важно задать стили для следующих состояний:

:checked для выбранного элемента;
:focus для элемента в фокусе;
:disabled для элемента, который нельзя изменить;
:checked:disabledдля выбранного элемента, который нельзя изменить;
Стилизация некоторых элементов форм не предусмотрена спецификациями и браузером. Дизайнеры со своей стороны могут предлагать изменить внешний вид. В таком случае можно использовать некоторую технику, позволяющую обойти ограничения.

Для радиокнопок и чекбоксов суть техники состоит в том чтобы

скрыть вид элемента по умолчанию;
сохранить поведение по умолчанию для элемента (изменение с помощью клавиши пробел и переход с помощью клавиши таб, например);
на месте скрытого элемента создать стилизованное изображение (стилизация с помощью фона, псевдоэлемента и т.п.).
Основная проблема состоит в том, как правильно скрыть элемент, не удалив его из DOM. Это важно, для того чтобы сохранить поведение по умолчанию.

Самый простой способ скрыть вид элемента элемент по умолчанию
это использование свойства appearance со значением none. Этот способ не поддерживается браузером Internet Explorer и требует дополнять запись этого свойства вендорными префиксами:

.hidden {
  -moz-appearance: none;
  -webkit-appearance: none;
  appearance: none;
}
Рассмотрим пример стилизации с помощью этого способа.

Задание
Есть готовая верстка `html` и заданы стили для элементов форм. Убедись в работе элементов, а именно что можно - перемещаться с помощью клавиши `Tab` - и менять значения с помощью `Space`.
С помощью свойства appearance со значением none скрой вид элементов по умолчанию. Для этого размести запись с вендорными префиксами
-moz-appearance и -webkit-appearance перед записью appearance: none.

Убедись что стилизованные элементы ведут себя также, как и элементы по умолчанию. */

body {
  --s: 20px;
  font-size: var(--s);
}
.container {
  display: flex;
  justify-content: space-between;
  max-width: 480px;
}
label {
  display: flex;
  justify-content: space-between;
}
.custom-input {
  display: block;
  width: var(--s);
  height: var(--s);
  background-color: crimson;
  position: relative;
  border: 4px solid transparent;
  color: #fff;
}
.custom-input[type="radio"] {
  border-radius: 50%;
}
.custom-input:checked {
  background-color: seagreen;
}
.custom-input:focus  {
  border: 4px solid hsla(0,0%,0%,.4);
  outline: none;
}
.custom-input:disabled  {
  background-color: lavender;
}
.custom-input:checked:disabled  {
  background-color: seagreen;
  opacity: .5;
}
.hidden {
  -moz-appearance: none; 
  -webkit-appearance: none;
  appearance: none;

}

/* Формы. Стилизация select.
После того как элемент скрыт, необходимо показать какой-то стилизованный элемент. Очень удобно использовать svg изображение. Изображение можно разместить в свойстве background-image: url() указав путь к файлу. Но можно вставить svg код напрямую, сделав необходимые преобразования.

Как сделать преобразование? Необходимо иметь готовое изображение svg и затем сделать преобразование на одном из сервисов

SVG to Data URI converter;
SVG to CSS background-image converter;
URL-encoder for SVG.
Например из svg треугольника

<svg width="16px" height="16px" viewBox="0 0 16 16" 
    version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
    preserveAspectRatio="xMidYMid">
  <g>
    <polygon points="0,0 16,0 8,16" fill="blue"/> 
  </g>
</svg> 
после преобразования можно получить такую строку:

"data:image/svg+xml;charset=UTF-8,%3csvg width='16px' height='16px' viewBox='0 0 16 16' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' preserveAspectRatio='xMidYMid'%3e%3cg%3e%3cpolygon points='0,0 16,0 8,16' fill='blue'/%3e%3c/g%3e%3c/svg%3e "
Задание
Есть готовый html и css код для стилизации select. У селектора .select-custom закомментировано свойство background-image с преобразованной строкой svg в качестве значения url и линейным градиентом.

Раскомментируй строку и убедись, что svg изображение можно вставлять inline не только в html, но и в css. */

* {
  box-sizing: border-box;
}
form {
  width: 28rem;
  margin: 1rem;
  padding: 2rem 1rem;
  font-size: 1rem;
  text-align: center;
  box-shadow: 0px 4px 4px hsla(0, 0%, 0%, 0.15);
}
button {
	display: block;
	margin: 0 auto 1rem;
}
.select-custom {

  /* 1 - скрой стили по умолчанию */
  -moz-appearance: none;
  -webkit-appearance: none;
  appearance: none;
  outline: none;

  /* 2 - задай размеры и положение */
  display: block;
  width: 100%;
  max-width: 100%;
  margin: 0 auto 1rem;
  padding: .6em 1.4em .5em .8em;

  /* оформи border */
  border: 1px solid #aaa;
  border-radius: .5em;

  /* оформи текст */
  font-size: 16px;
  font-family: sans-serif;
  font-weight: 700;
  color: #444;
  line-height: 1.3;

  /* оформи тень от блока */
  box-shadow: 0 1px 0 1px hsla(0, 0%, 0%, 0.04);

  /* оформи фон и фоновое изображение */
  background-repeat: no-repeat;
  background-position: right .7rem top 50%, 0 0;
  background-size: .65rem auto, 100%;
  
  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg width='16px' height='16px' viewBox='0 0 16 16' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' preserveAspectRatio='xMidYMid'%3e%3cg%3e%3cpolygon points='0,0 16,0 8,16' fill='blue'/%3e%3c/g%3e%3c/svg%3e"),
  linear-gradient(to bottom, #ffffff 0%, #e5e5e5 100%);
  
}

/* Формы. Псевдоклассы состояний.
Задание
Задана верстка html формы и оформлены стили css. Необходимо дополнить стили оформлением элемента input для плейсхолдера и для валидного и невалидного контента. Для этого:

Для селектора псевдоэлемента input::placeholder задай цвет текста rebeccapurple;

Для селектора input:not(:placeholder-shown) с псевдоклассом

:valid  задай свойство border-color со значением seagreen;
:invalid  задай свойство border-color со значением crimson.
Обрати внимание на то как срабатывает валидация для input с атрибутом pattern=".{3,5}" - валидация происходит только если количество символов в этом элементе от 3-х до 5-ти. */

form {
  max-width: 360px;
  margin: auto;
  padding: 1rem 2rem 1rem 1rem;
  border-radius: .25rem;
  box-shadow: 2px 2px 6px 3px hsla(0, 0%, 0%, .2);
  font-family: sans-serif;
  text-transform: uppercase;
}
.buttons,
label {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
label {
  margin-bottom: 1.5rem;
}
label span {
  opacity: .6;
}
input {
  border: 2px solid lavender;
  padding: 4px;
  border-radius: .25rem;
}
button {
  padding: .5rem 1.75rem;
  border-radius: .25rem;
  text-transform: uppercase;
  border: none;
  outline: none;
  opacity: .6;
  background-color: gray;
  color: #fff;
}
button:hover {
  background-color: gray;
  opacity: 1;
}

/* placeholder */
input::placeholder {
  /* Напиши код под этой строкой; */
  color: rebeccapurple;

}

/* focus-within */
label:focus-within span {
  opacity: 1;
}
form:focus-within button[type="submit"] {
  opacity: .6;
  background-color: seagreen;
}
form:focus-within  button[type="reset"]{
  opacity: .6;
  background-color: crimson;
}
form:focus-within {
  box-shadow: 1px 1px 2px 2px hsla(0, 0%, 0%, .3);
}

/* valid */
form:valid button {
  color: #fff;
  pointer-events: none;
}

/* combination  */
form:focus-within:valid button {
  opacity: 1;
}
input:not(:placeholder-shown):valid {
  /* Напиши код под этой строкой; */
  border-color: seagreen;

}
input:not(:placeholder-shown):invalid {
  /* Напиши код под этой строкой; */
  border-color: crimson;
}

